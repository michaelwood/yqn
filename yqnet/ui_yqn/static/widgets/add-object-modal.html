<scipt type="text/template" id="modal-template">
    <div class="modal fade" tabindex="-1" role="dialog" v-bind:id="modalId">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">{{title}}</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div v-if="error" class="alert alert-warning">Please check the form.
                            <span v-for="(value, key) in error" class="alert-error"><strong>{{key}}</strong> - <span v-for="msg in value">{{msg}} </span>
                        </span>
                    </div>

                    <p>{{info}}</p>

                    <form>
                        <transition-group tag="div" name="list">

                        <div v-for="field in fields" class="form-group list-item" v-bind:key="field.name">
                            <label v-bind:for="field.name">{{field.data.label}} <span v-if="field.data.required" style="color:red">*</span></label>

                                <location v-if="field.name == 'postcode'" v-bind:field="field" v-on:selected="autocompleteSelected"></location>
                                <input v-else-if="field.name == 'lat' || field.name == 'lng'" type="text" v-bind:value="input[field.name]" placeholder="Use postcode lookup" v-bind:name="field.name" class="form-control" v-bind:id="field.name"  readonly>
                                <slug v-else-if="field.name == 'slug'" type="text" v-bind:from="input['title']" v-model="input[field.name]" v-bind:name="field.name" v-bind:id="field.name" v-on:selected="autocompleteSelected"></slug>

                                <input v-else-if="field.data.max_length" v-bind:name="field.name" type="text" class="form-control" v-model="input[field.name]"  v-bind:id="field.name" >
                                <div v-else-if="field.data.type === 'boolean'" class="form-check">
                                    <input v-bind:name="field.name" type="checkbox" class="form-check-input" v-model="input[field.name]"  v-bind:id="field.name" >
                                    <label class="form-check-label">{{field.data.label}}</label>
                                </div>
                                <textarea v-else-if="field.data.type ==='string' && !field.data.max_length" v-bind:id="field.name" v-bind:name="field.name" class="form-control" v-model="input[field.name]" ></textarea>

                                <datetime v-else-if="field.data.type === 'datetime'" v-on:selected="autocompleteSelected" v-bind:name="field.name"></datetime>
                                <fk-autocomplete v-else-if="field.data.type === 'field'" v-bind:name="field.name" v-on:selected="autocompleteSelected" v-bind:model-hint="field.data.model_hint"></fk-autocomplete>

                                <div v-else-if="field.data.type === 'choice'">
                                    <select v-bind:name="field.name" class="form-control" v-model="input[field.name]"  v-bind:id="field.name">
                                        <option v-for="choice in field.data.choices" v-bind:value="choice.value">{{choice.display_name}}</option>
                                    </select>
                                </div>
                                <small>{{field.data.help_text}}</small>
                        </div>
                        </transition-group>

                    </form>
                </div>
                <div class="modal-footer">
                    <button v-if="creationStack.length" v-on:click.prevent="resumeState" class="btn btn-primary">Back</button>

                    <button type="button" class="btn btn-secondary" v-on:click="close" data-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" v-on:click="add">
                        <span v-if="creationStack.length">Next</span>
                        <span v-else>Add</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</scipt>

<script type="text/javascript">

/* <datetime> Date and time picker
 * Makes uses of vueJSDatepicker to do the heavy lifting
 * https://github.com/charliekassel/vuejs-datepicker
 * Extends this to have hour/minute field and use our pattern of event handling
 */

Vue.component('datetime', {
    props: ['name'],

    components: {
        /* Note this symbol is currently loaded in base.html */
        vuejsDatepicker
    },
        template: '<div class="d-flex flex-column">  \
                    <vuejs-datepicker :required="true" :bootstrap-styling="true" :inline="true" v-on:selected="dateSelected" v-model="date"></vuejs-datepicker> \
                    <div class="pt-2 form-row"> \
                        <div class="col"> \
                            <label>Hour</label> \
                            <select class="form-control" v-on:change="hourSelected"><option v-for="(useless, h) in 24">{{h}}</option></select> \
                        </div> \
                        <div class="col"> \
                            <label>Minute</label> \
                            <select class="form-control" v-on:change="minuteSelected"><option v-for="(useless, m) in 60">{{m}}</option></select>\
                        </div> \
                    </div> \
                   </div>',

    data: function(){
        return {
            date: null,
            timedate: new Date(),
        }
    },

    methods: {
        dateSelected: function(date){
            this.timedate.setDate(date.getDate());
            this.$emit("selected", { key: this.name, value: this.timedate });
        },

        minuteSelected: function(e){
            let minute = Number(e.srcElement.value);
            this.timedate.setMinutes(minute);
            this.$emit("selected", { key: this.name, value: this.timedate });
        },

        hourSelected: function(e){
            let hour = Number(e.srcElement.value);
            this.timedate.setHours(hour);
            this.$emit("selected", { key: "datetime", value: this.timedate });
        },
    }
});

/* <slug> uses a named field (from) to suggest an appropirately formatted slug */
Vue.component('slug', {
    props: ['name', 'id', 'from'],

    template: '<input type="text" v-bind:name="name" v-bind:id="id" v-model="suggestion" class="form-control" v-on:keyup="keyup" />',

    data: function(){
        return {
            suggestion: '',
            edited: false,
        }
    },

    watch: {
        from : "makeSuggestion",
    },


    methods: {

        keyup: function(){
            this.edited = true;
            this.$emit("selected", { key: "slug", value: this.suggestion });
        },

        makeSuggestion: function(){
            /* stop making suggestions if a slug has been modified/entered */
            if (this.edited && this.from.length > 0){
                return;
            }

            var str = this.from;

            /* modified from http://dense13.com/blog/2009/05/03/converting-string-to-slug-javascript/ */
            str = str.replace(/^\s+|\s+$/g, ''); // trim
            str = str.toLowerCase();

            str = str.replace(/[^a-z0-9 -]/g, '') // remove invalid chars
                .replace(/\s+/g, '-') // collapse whitespace and replace by -
                .replace(/-+/g, '-'); // collapse dashes

            this.suggestion = str;

            this.$emit("selected", { key: "slug", value: this.suggestion });
        },
    },
});

/* <location> Uses mapit to look up lat/lnglocation from the postcode
*  This is a little clunky but offloads hitting their API to the client
*/
Vue.component('location', {
    props: ['field'],

    data: function(){
        return {
            postcode: null,
            searching: false,
         }
     },

    template: '<div class="input-group mb-3"> \
              <input type="text" class="form-control border-right-0" v-bind:id="field.name" v-model="postcode" v-bind:name="field.name" aria-label="postcode with lookup button addon" aria-describedby="button-addon1"> \
                <div class="input-group-append"> \
                    <button class="btn btn-outline-secondary" type="button" v-on:click.prevent="lookup" id="button-addon1">Lookup map position \
                    <div class="spinner-border spinner-border-sm d-none" v-bind:class="{ \'d-inline-block\' : searching }" role="status" aria-hidden="true"></div> \
                    </button> \
                </div> \
              </div>',

    methods: {
        lookup: function(){
            this.searching  = true;
            var ctx = this;

            $.getJSON("https://mapit.mysociety.org/postcode/" + this.postcode,
             function(data){
                if (data.length == 0){
                    return;
                }

                ctx.$emit("selected", { key: "lat", value: data.wgs84_lat });
                ctx.$emit("selected", { key: "lng", value: data.wgs84_lon });
                ctx.$emit("selected", { key: "postcode", value: data.postcode });

                ctx.searching = false;
            }).fail(
             function(){
                console.log("error doing postcode lookup");
                ctx.searching = false;

            });

        },

    },
});

/* <fk-autocomplete> When the field is a foreign key look up the possible
 * keys/values and create a very basic autocomplete field
*/
Vue.component('fk-autocomplete', {
    props: ['name', 'modelHint'],

    template: '<div> \
                <input type="text" placeholder="Search..." class="form-control" v-model="searchText" v-bind:id="name"> \
                <div class="flex-column shadow-sm border d-none list-group" v-bind:class="{ \'d-flex\':  selectionActive }"> \
                  <div class="spinner-border spinner-border-sm ml-auto m-2 float-right d-none" v-bind:class="{ \'d-block\' : searching }" role="status" aria-hidden="true"></div> \
                  <a href="#" v-for="option in options" class="list-group-item list-group-item-action p-2" v-on:click.prevent="selected(option.id, option.title)">{{option.title}}</a> \
                </div> \
               </div>',

    data: function(){
        return {
            searchText: "",
            options: [],
            searching: false,
            selectionActive: false,
            selection: "",
            urlHint: "",
        }

    },

    watch: {
        searchText: "search",
    },

    methods: {
        search: function(){
            /* We've just set our searchText via the selection so don't search again */
            if (this.searchText == this.selection){
                return;
            }
            var ctx = this;
            if (this.searchText.length < 2){
                this.options = [];
                return;
            }
            this.selectionActive = true;
            this.searching = true;

            $.getJSON("/api/"+this.modelHint+"/?search="+this.searchText, function(result){
                ctx.options = result;
                ctx.searching = false;
                ctx.options.push({ id: "__new__", title: "Add new..." });
            });

        },
        selected: function(id, title) {
            this.selectionActive = false;
            console.log("selected "+ id);
            this.selection = title;

            /* value is id this sounds strange but id is the fk of the object
             * selected
             */
            var selected = { key: this.name, value: id };

            if (id === "__new__"){
                selected.modelHint = this.modelHint;
            }

            this.$emit("selected", selected);
            this.searchText = title;
            this.options = [];
        },

    },
});

/* Main component for the form */
Vue.component('add-object-modal', {
        template: "#modal-template",

        props: ['start-model', 'title', 'success'],

        data: function(){
            return {
                modalId: "add-object-modal-" + this.startModel,
                fields: [],
                info: "",
                input: {},
                error: null,
                creationStack: [],
                tinyMCE: false,
                model: this.startModel,
             }
        },

        mounted: function (){
            this.fetchData();
            console.log(this.model);
        },

        watch: {
            model: 'fetchData',
            fields: 'maybeInitTinyMCE',
        },

        methods: {
            /* Introspect the model to generate the form */
            fetchData: function(){

                var ctx = this;
                $.ajax({
                    url: "/api/" + ctx.model,
                    method: "OPTIONS",
                    success: function(data){
                        console.log("getting metadata for model")
                        if (data.description){
                            ctx.info = data.description;
                        }

                        var fields = Object.keys(data.actions.POST);
                        var fieldsArray = []

                        for (var i in fields){
                            /* We don't need the read_only fields
                             * also not going to handled nested fields yet
                             */
                            if (data.actions.POST[fields[i]].read_only == true ||
                                data.actions.POST[fields[i]].type == "nested object"){
                                continue;
                            }

                            /* Set the selector ID to indicate if we're going need to
                             * initalise the tinyMCE editor
                             */
                            if (data.actions.POST[fields[i]].type ==='string' &&
                                !data.actions.POST[fields[i]].max_length){
                                 ctx.tinyMCE = "#" + fields[i];
                             }

                            var field = {
                                name : fields[i],
                                data: data.actions.POST[fields[i]]
                            };

                            fieldsArray.push(field);
                        }

                        ctx.fields = fieldsArray;
                    },
                });



            },

            add: function(){
                console.log("input "+JSON.stringify(this.input));
                var url =  "/api/" + this.model + "/";
                var ctx = this;

                if (this.tinyMCE){
                    this.input[tinyMCE.activeEditor.getElement().name] = tinyMCE.activeEditor.getContent();
                }

                $.ajax({
                    type: "POST",
                    url: url,
                    data: JSON.stringify(this.input),
                    contentType: 'application/json',
                    accept: 'application/json',
                    headers: { 'X-CSRFToken': Cookies.get('csrftoken') },
                    success: function (data) {
                        console.log("all good");
                        console.log(data);
                        yqnBus.$emit("data-added", this.input);


                        /* Clear the current form and any errors */
                        ctx.error = null;

                        if (ctx.creationStack.length > 0){
                            ctx.resumeState();
                            return;
                        }

                        $("#"+ctx.modalId).modal('hide');

                        for (i in ctx.input){
                            ctx.input[i] = '';
                        }

                        /* TODO this is a bit messy transition case */
                        if (data.go_to){
                            window.location = data.go_to;
                        }

                        yqnBus.$emit("notify", {
                            'title': ctx.title + " success",
                            'body': ctx.success,
                        });

                    },
                    error: function (error) {
                        console.log(error);
                        /* TODO Make the error messages more friendly */
                        window.scroll(0,0);
                        ctx.error = error.responseJSON;
                    },
                });

                return false;
            },

            autocompleteSelected: function(data){
                if (data.value === "__new__"){
                    /* We're switching models to be able to add the new object */
                    this.switchModel(data.modelHint);
                    return;
                }
                /* Vue set triggers the bindings correctly (as aposed to directly setting the value) */
                Vue.set(this.input, data.key, data.value);
            },

            switchModel: function(newModel){
                this.saveState();

                if (!newModel){
                    throw("No new model given");
                    return;
                }

                /* Reset current state */
                this.input = {};
                this.fields = [];
                this.error = null;
                this.tinyMCE = false; // This then fails to get set to true at the rhgint point... TODO
                this.model = newModel;
            },

            saveState: function(){
                var state = {
                    model: this.model,
                    input: this.input,
                };

                this.creationStack.push(state);
            },

            resumeState: function(){
               var state = this.creationStack.pop();

               this.model = state.model;
               this.input = state.input;
            },

            close: function(){

                /* Go back to the start of the stack and delete the stack */
                if (this.creationStack.length > 0){
                    this.model = this.creationStack[0].model;
                    this.creationStack = [];
                }

                this.input = {};
            },

            maybeInitTinyMCE: function(){
                this.$nextTick(function(){

                    if (typeof(tinyMCE) === 'undefined'){
                        console.log("No tinyMCE");
                        return;
                    }

                    try {
                        tinyMCE.activeEditor.remove();
                        /* It doesn't really up after itself :( */
                        $(".mce-tinymce").remove();
                    } catch {}

                    if (this.tinyMCE){

                        let ctx = this;
                        /* TinyMCE appears to be racy without this
                        * About 1 in 4 loads fail if it isn't deffered :(
                        */
                        setTimeout(function(){
                            console.log("Init tinymce: " + ctx.tinyMCE);
                            tinyMCE.init({
                                selector: ctx.tinyMCE,
                                plugins: "autolink code lists emoticons",
                                menubar: false,
                                toolbar: "undo redo bold italic underline lists emoticons | code",
                                statusbar: false,
                            });
                        }, 0);
                    }
                });
            },

        }, /* End methods */

    });

var modalObjApp = new Vue({
    el: '#add-object-modal-app',
});

</script>